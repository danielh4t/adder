<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Visual Clarity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: radial-gradient(circle, #1e3c72, #2a5298);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 600px;
            max-height: 600px;
            background: linear-gradient(135deg, #0d1117, #161b22);
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            touch-action: pan-y pan-x;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .score {
            padding: 10px 15px;
            font-size: 18px;
            text-align: center;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            font-size: 24px;
            color: #fff;
            display: none;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.6);
        }

        .game-over button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #e63946;
            color: #fff;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .game-over button:hover {
            background: #d62839;
        }
    </style>

<body>
    <div>
        <div id="score" class="score">Score: 0</div>
        <div class="game-container" id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div class="game-over" id="gameOver">Game Over!<br><button onclick="restartGame()">Restart</button></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        canvas.width = canvas.height = Math.min(window.innerWidth * 0.9, 600);

        const box = canvas.width / 30;
        let score = 0;
        let speed = 150;
        let snake = [];
        let direction = 'RIGHT';
        let food;
        let gameLoop;
        let lastFrameTime = 0;
        const cornerRadius = 5;
        let touchStartX = null;
        let touchStartY = null;
        let isPaused = false;
        let foodEatenEffect = false;
        let foodEatenEffectTimer = 0;
        const foodEatenEffectDuration = 5;
        let directionQueue = [];

        function initGame() {
            snake = [{ x: box * 5, y: box * 5 }];
            food = generateFood();
            score = 0;
            speed = 150;
            direction = 'RIGHT';
            directionQueue = [];
            updateScoreDisplay();
            hideGameOver();
            isPaused = false;
            foodEatenEffect = false;
            foodEatenEffectTimer = 0;
        }

        function generateFood() {
            let foodX, foodY;
            do {
                foodX = Math.floor((Math.random() * canvas.width) / box) * box;
                foodY = Math.floor((Math.random() * canvas.height) / box) * box;
            } while (isFoodOnSnake(foodX, foodY));
            return { x: foodX, y: foodY };
        }

        function isFoodOnSnake(foodX, foodY) {
            return snake.some(segment => segment.x === foodX && segment.y === foodY);
        }

        function changeDirection(event) {
            let newDirection = getDirectionFromInput(event);
            if (newDirection) {
                enqueueDirection(newDirection);
            }
        }

        function enqueueDirection(newDirection) {
            const oppositeDirections = {
                UP: 'DOWN',
                DOWN: 'UP',
                LEFT: 'RIGHT',
                RIGHT: 'LEFT'
            };
            if (directionQueue.length === 0 || newDirection !== oppositeDirections[directionQueue[directionQueue.length - 1]]) {
                directionQueue.push(newDirection);
            }
        }


        function getDirectionFromInput(event) {
            if (event.key) {
                return {
                    ArrowUp: 'UP',
                    ArrowDown: 'DOWN',
                    ArrowLeft: 'LEFT',
                    ArrowRight: 'RIGHT'
                }[event.key];
            } else if (event.direction) {
                return event.direction;
            }
            return null;
        }


        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFood();
            drawSnake();
            if (isPaused) {
                drawPauseScreen();
            }
        }

        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
        }


        function drawSnake() {
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#00bbff' : '#0099cc'; // Enhanced snake colors
                drawRoundedRect(ctx, segment.x, segment.y, box, box, cornerRadius);
                ctx.fill();
                ctx.strokeStyle = '#161b22';
                ctx.stroke();
            });
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            radius = Math.min(radius, Math.min(width / 2, height / 2));
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawFood() {
            ctx.fillStyle = '#ff4444'; // Enhanced food color
            let foodSize = box / 2.5;
            if (foodEatenEffect && foodEatenEffectTimer > 0) {
                const scaleFactor = 1 + 0.2 * (foodEatenEffectTimer / foodEatenEffectDuration);
                foodSize *= scaleFactor;
                foodEatenEffectTimer--;
                if (foodEatenEffectTimer === 0) {
                    foodEatenEffect = false;
                }
            }
            ctx.beginPath();
            ctx.arc(food.x + box / 2, food.y + box / 2, foodSize, 0, Math.PI * 2);
            ctx.fill();
        }

        function moveSnake() {
            if (directionQueue.length > 0) {
                const nextDirection = directionQueue.shift();
                const oppositeDirections = {
                    UP: 'DOWN',
                    DOWN: 'UP',
                    LEFT: 'RIGHT',
                    RIGHT: 'LEFT'
                };
                if (nextDirection !== oppositeDirections[direction]) {
                    direction = nextDirection;
                }
            }
            const head = getNextHeadPosition();
            snake.unshift(head);

            if (isFoodEaten(head)) {
                eatFood();
            } else {
                snake.pop();
            }
        }

        function getNextHeadPosition() {
            const head = { ...snake[0] };
            switch (direction) {
                case 'UP': head.y -= box; break;
                case 'DOWN': head.y += box; break;
                case 'LEFT': head.x -= box; break;
                case 'RIGHT': head.x += box; break;
            }
            return head;
        }

        function isFoodEaten(head) {
            return head.x === food.x && head.y === food.y;
        }

        function eatFood() {
            score += 10;
            updateScoreDisplay();
            food = generateFood();
            increaseSpeed();
            resetGameLoop();
            foodEatenEffect = true;
            foodEatenEffectTimer = foodEatenEffectDuration;
        }

        function increaseSpeed() {
            if (speed > 50) speed -= 5;
        }

        function checkCollision() {
            if (isCollision()) {
                gameOver();
            }
        }

        function isCollision() {
            const head = snake[0];
            return head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height || isSelfCollision();
        }

        function isSelfCollision() {
            const head = snake[0];
            return snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
        }


        function updateScoreDisplay() {
            document.getElementById('score').innerText = `Score: ${score}`;
        }

        function hideGameOver() {
            document.getElementById('gameOver').style.display = 'none';
        }

        function showGameOver() {
            document.getElementById('gameOver').style.display = 'block';
        }

        function gameOver() {
            showGameOver();
            stopGameLoop();
        }

        function restartGame() {
            initGame();
            startGameLoop();
        }

        function update() {
            moveSnake();
            checkCollision();
            draw();
        }

        function gameCycle(timestamp) {
            if (!isPaused) {
                if (!lastFrameTime) lastFrameTime = timestamp;
                let progress = timestamp - lastFrameTime;
                if (progress > speed) {
                    update();
                    lastFrameTime = timestamp;
                }
                gameLoop = requestAnimationFrame(gameCycle);
            }
        }

        function startGameLoop() {
            resetGameLoop();
        }

        function stopGameLoop() {
            cancelAnimationFrame(gameLoop);
        }


        function resetGameLoop() {
            stopGameLoop();
            lastFrameTime = 0;
            gameLoop = requestAnimationFrame(gameCycle);
        }

        function pauseGame() {
            isPaused = true;
            stopGameLoop();
            draw();
        }

        function resumeGame() {
            isPaused = false;
            lastFrameTime = performance.now();
            startGameLoop();
        }


        document.addEventListener('keydown', changeDirection);
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        });


        gameContainer.addEventListener('touchstart', function(event) {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }, false);

        gameContainer.addEventListener('touchend', function(event) {
            if (touchStartX === null || touchStartY === null) return;

            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            let touchDirection = '';

            if (Math.abs(dx) > Math.abs(dy)) {
                touchDirection = dx > 0 ? 'RIGHT' : 'LEFT';
            } else {
                touchDirection = dy > 0 ? 'DOWN' : 'UP';
            }

            if (touchDirection) changeDirection({ direction: touchDirection });

            touchStartX = null;
            touchStartY = null;
        }, false);

        window.addEventListener('resize', () => {
            canvas.width = canvas.height = Math.min(window.innerWidth * 0.9, 600);
            initGame();
            resetGameLoop();
        });


        initGame();
        startGameLoop();
    </script>
</body>

</html>