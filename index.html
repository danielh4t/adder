<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game with Delta-Time Game Loop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: radial-gradient(circle, #1e3c72, #2a5298);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 600px;
            max-height: 600px;
            background: linear-gradient(135deg, #0d1117, #161b22);
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            touch-action: pan-y pan-x;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .score-container {
            padding: 10px 15px;
            font-size: 18px;
            text-align: center;
        }

        .score {
            margin-bottom: 5px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            font-size: 24px;
            color: #fff;
            display: none;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.6);
        }

        .game-over button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #e63946;
            color: #fff;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .game-over button:hover {
            background: #d62839;
        }
    </style>
</head>

<body>
    <div>
        <div class="score-container">
            <div id="score" class="score">Score: 0</div>
            <div id="highScore" class="score">High Score: 0</div>
        </div>
        <div class="game-container" id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div class="game-over" id="gameOver">Game Over!<br><button id="restartButton">Restart</button></div>
        </div>
    </div>
    <script>
        class Snake {
            constructor(box) {
                this.box = box;
                this.reset();
            }

            reset() {
                this.segments = [{ x: this.box * 5, y: this.box * 5 }];
                this.direction = 'RIGHT';
                this.directionQueue = [];
            }

            enqueueDirection(newDirection) {
                const oppositeDirections = {
                    UP: 'DOWN',
                    DOWN: 'UP',
                    LEFT: 'RIGHT',
                    RIGHT: 'LEFT'
                };
                if (this.directionQueue.length === 0 || newDirection !== oppositeDirections[this.directionQueue[this.directionQueue.length - 1]]) {
                    this.directionQueue.push(newDirection);
                }
            }

            getNextHeadPosition() {
                const head = { ...this.segments[0] };
                switch (this.direction) {
                    case 'UP': head.y -= this.box; break;
                    case 'DOWN': head.y += this.box; break;
                    case 'LEFT': head.x -= this.box; break;
                    case 'RIGHT': head.x += this.box; break;
                }
                return head;
            }

            move() {
                if (this.directionQueue.length > 0) {
                    const nextDirection = this.directionQueue.shift();
                    const oppositeDirections = {
                        UP: 'DOWN',
                        DOWN: 'UP',
                        LEFT: 'RIGHT',
                        RIGHT: 'LEFT'
                    };
                    if (nextDirection !== oppositeDirections[this.direction]) {
                        this.direction = nextDirection;
                    }
                }
                const head = this.getNextHeadPosition();
                this.segments.unshift(head);
                return head;
            }

            pop() {
                this.segments.pop();
            }

            isCollision() {
                const head = this.segments[0];
                return this.segments.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
            }

            draw(ctx, cornerRadius) {
                this.segments.forEach((segment, index) => {
                    ctx.fillStyle = index === 0 ? '#00bbff' : '#0099cc';
                    Game.drawRoundedRect(ctx, segment.x, segment.y, this.box, this.box, cornerRadius);
                    ctx.fill();
                    ctx.strokeStyle = '#161b22';
                    ctx.stroke();
                });
            }
        }

        class Food {
            constructor(box, canvasWidth, canvasHeight, snakeSegments) {
                this.box = box;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.snakeSegments = snakeSegments;
                this.generate();
            }

            generate() {
                let foodX, foodY;
                do {
                    foodX = Math.floor((Math.random() * this.canvasWidth) / this.box) * this.box;
                    foodY = Math.floor((Math.random() * this.canvasHeight) / this.box) * this.box;
                } while (this.isOnSnake(foodX, foodY));
                this.position = { x: foodX, y: foodY };
            }

            isOnSnake(x, y) {
                return this.snakeSegments.some(segment => segment.x === x && segment.y === y);
            }

            draw(ctx, effect, effectTimer, duration, box) {
                ctx.fillStyle = '#ff4444';
                let foodSize = box / 2.5;
                if (effect && effectTimer > 0) {
                    const scaleFactor = 1 + 0.2 * (effectTimer / duration);
                    foodSize *= scaleFactor;
                }
                ctx.beginPath();
                ctx.arc(this.position.x + box / 2, this.position.y + box / 2, foodSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('gameContainer');
                this.scoreElement = document.getElementById('score');
                this.highScoreElement = document.getElementById('highScore');
                this.gameOverElement = document.getElementById('gameOver');
                this.restartButton = document.getElementById('restartButton');
                this.box = 20;
                this.canvasSize = Math.min(window.innerWidth * 0.9, 600);
                this.canvas.width = this.canvas.height = this.canvasSize;
                this.reset();
                this.addEventListeners();
                this.startLoop();
            }

            reset() {
                this.score = 0;
                this.speed = 150;
                this.snake = new Snake(this.box);
                this.food = new Food(this.box, this.canvas.width, this.canvas.height, this.snake.segments);
                this.foodEffect = false;
                this.foodEffectTimer = 0;
                this.isPaused = false;
                this.lastFrameTime = 0;
                this.accumulatedTime = 0;
                this.hideGameOver();
                this.highScore = parseInt(localStorage.getItem('highScore')) || 0;
                this.updateScore();
            }

            static drawRoundedRect(ctx, x, y, width, height, radius) {
                radius = Math.min(radius, Math.min(width / 2, height / 2));
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            updateScore() {
                this.scoreElement.innerText = `Score: ${this.score}`;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('highScore', this.highScore);
                }
                this.highScoreElement.innerText = `High Score: ${this.highScore}`;
            }

            showGameOver() {
                this.gameOverElement.style.display = 'block';
            }

            hideGameOver() {
                this.gameOverElement.style.display = 'none';
            }

            gameOver() {
                this.showGameOver();
                this.stopLoop();
            }

            restart() {
                this.reset();
                this.startLoop();
            }

            addEventListeners() {
                document.addEventListener('keydown', (event) => {
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                        const direction = {
                            ArrowUp: 'UP',
                            ArrowDown: 'DOWN',
                            ArrowLeft: 'LEFT',
                            ArrowRight: 'RIGHT'
                        }[event.key];
                        this.snake.enqueueDirection(direction);
                    }
                    if (event.code === 'Space') {
                        if (this.isPaused) {
                            this.resume();
                        } else {
                            this.pause();
                        }
                    }
                });

                this.container.addEventListener('touchstart', (event) => {
                    this.touchStartX = event.touches[0].clientX;
                    this.touchStartY = event.touches[0].clientY;
                }, false);

                this.container.addEventListener('touchend', (event) => {
                    if (this.touchStartX === null || this.touchStartY === null) return;

                    const touchEndX = event.changedTouches[0].clientX;
                    const touchEndY = event.changedTouches[0].clientY;

                    const dx = touchEndX - this.touchStartX;
                    const dy = touchEndY - this.touchStartY;

                    let touchDirection = '';

                    if (Math.abs(dx) > Math.abs(dy)) {
                        touchDirection = dx > 0 ? 'RIGHT' : 'LEFT';
                    } else {
                        touchDirection = dy > 0 ? 'DOWN' : 'UP';
                    }

                    if (touchDirection) this.snake.enqueueDirection(touchDirection);

                    this.touchStartX = null;
                    this.touchStartY = null;
                }, false);

                this.restartButton.addEventListener('click', () => this.restart());

                window.addEventListener('resize', () => {
                    this.canvasSize = Math.min(window.innerWidth * 0.9, 600);
                    this.canvas.width = this.canvas.height = this.canvasSize;
                    this.box = this.canvasSize / 30;
                    this.reset();
                });
            }

            pause() {
                this.isPaused = true;
                this.stopLoop();
                this.drawPauseScreen();
            }

            resume() {
                this.isPaused = false;
                this.lastFrameTime = performance.now();
                this.startLoop();
            }

            drawPauseScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = 'white';
                this.ctx.font = '48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Paused', this.canvas.width / 2, this.canvas.height / 2);
            }

            update() {
                const head = this.snake.move();

                if (this.checkCollision(head)) {
                    this.gameOver();
                    return;
                }

                if (head.x === this.food.position.x && head.y === this.food.position.y) {
                    this.score += 10;
                    this.updateScore();
                    this.food = new Food(this.box, this.canvas.width, this.canvas.height, this.snake.segments);
                    this.increaseSpeed();
                    this.foodEffect = true;
                    this.foodEffectTimer = 5;
                } else {
                    this.snake.pop();
                }

                this.draw();
            }

            checkCollision(head) {
                return head.x < 0 || head.x >= this.canvas.width || head.y < 0 || head.y >= this.canvas.height || this.snake.isCollision();
            }

            increaseSpeed() {
                if (this.speed > 50) this.speed -= 5;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.food.draw(this.ctx, this.foodEffect, this.foodEffectTimer, 5, this.box);
                this.snake.draw(this.ctx, 5);
                if (this.foodEffect && this.foodEffectTimer > 0) {
                    this.foodEffectTimer--;
                    if (this.foodEffectTimer === 0) {
                        this.foodEffect = false;
                    }
                }
                if (this.isPaused) {
                    this.drawPauseScreen();
                }
            }

            gameCycle = (timestamp) => {
                if (!this.lastFrameTime) {
                    this.lastFrameTime = timestamp;
                }
                const deltaTime = timestamp - this.lastFrameTime;
                this.lastFrameTime = timestamp;
                this.accumulatedTime += deltaTime;

                while (this.accumulatedTime > this.speed) {
                    if (!this.isPaused) {
                        this.update();
                    }
                    this.accumulatedTime -= this.speed;
                }

                this.gameLoop = requestAnimationFrame(this.gameCycle);
            }

            startLoop() {
                this.lastFrameTime = performance.now();
                this.gameLoop = requestAnimationFrame(this.gameCycle);
            }

            stopLoop() {
                cancelAnimationFrame(this.gameLoop);
            }
        }

        const game = new Game();
    </script>
</body>

</html>